// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include <iostream>
#include <string>

#include "Subsystems/DriveBase.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/DriveWithJoy.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveBase::DriveBase() : frc::Subsystem("DriveBase") {
    driveTrainLeftTalonSlave.reset(new WPI_TalonSRX(10));
    driveTrainRightTalonSlave.reset(new WPI_TalonSRX(11));
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    driveTrainLeftTalon.reset(new WPI_TalonSRX(0));
    driveTrainRightTalon.reset(new WPI_TalonSRX(1));
    driveTrain.reset(new frc::DifferentialDrive(*driveTrainLeftTalon, *driveTrainRightTalon));
    ultrasonicLeft.reset(new frc::AnalogInput(1));
    ultrasonicRight.reset(new frc::AnalogInput(2));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    driveBackSpeed = -1.0;
    driveStraightSpeed = 1.0;
    distanceToLeftObject = 0;
    piggy.reset(new PigeonIMU(0));
    //piggy.reset(new PigeonIMU(*driveTrainLeftTalon));
   // piggy = new PigeonIMU(driveTrainLeftTalon);
}

void DriveBase::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new DriveWithJoy());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        driveTrainLeftTalonSlave->Follow(*driveTrainLeftTalon);
        driveTrainRightTalonSlave->Follow(*driveTrainRightTalon);
        
        //Left DriveTrain
        driveTrainLeftTalon->SetInverted(true);
        driveTrainLeftTalonSlave->SetInverted(true);

        //Right DriveTrain
        driveTrainRightTalon->SetInverted(true);
        driveTrainRightTalonSlave->SetInverted(true);

        driveTrainLeftTalon->SetSensorPhase(true);
        driveTrainRightTalon->SetSensorPhase(true);

        const int kTimeoutMs = 30;
        piggy->SetFusedHeading(0.0, kTimeoutMs); /* reset heading, angle measurement wraps at plus/minus 23,040 degrees (64 rotations) */
}

void DriveBase::Periodic() {
    // Put code here to be run every loop
   }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveBase::showInfo(){ //formally called PrintEncoderSpeed
int leftPos = driveTrainLeftTalon->GetSelectedSensorPosition(0);
int rightPos = driveTrainRightTalon->GetSelectedSensorPosition(1);



int distance = getCurrentEncoderPos();
double dir = getCurrentAngle();
double frontUltrasonic = getInchesToObject();
int elpos = Robot::elevator->GetElPosition();

std::cout 	<< "dir : " << dir << std::endl;
std::cout 	<< "leftPos : " << leftPos << std::endl;
std::cout 	<< "rightPos : " << rightPos << std::endl;
std::cout 	<< "distance : " << distance << std::endl;
std::cout 	<< "frontUltrasonic : " << frontUltrasonic << std::endl;
std::cout 	<< "elpos : " << elpos << std::endl;
}

void DriveBase::resetAhrs(){
    
}

double DriveBase::getCurrentEncoderPos(){
    double encoderReading = driveTrainLeftTalon->GetSelectedSensorPosition(0);
    return encoderReading / 1831.645; //convert the sensor reading to inches
}

double DriveBase::getInchesToObject(){
    double voltage = ultrasonicLeft->GetAverageVoltage();
    double dist_mm = voltage/0.977*1000;
    double dist_in = dist_mm/25.4;
    return dist_in;
}

void DriveBase::DriveStraight(double driveStraightSpeed){
    driveTrain->TankDrive(driveStraightSpeed, driveStraightSpeed);
}

void DriveBase::Halt(){
    driveTrain->TankDrive(0.0,0.0);
}

void DriveBase::JoyDrive(double myX, double myY){
    driveTrain->TankDrive(myX, myY);
}

void DriveBase::turnToAngle(double degree){
    double c = getCurrentAngle();
    double e;
    time_t start = time(NULL);
    e=c+degree;
    if(degree>=0){
        while(getCurrentAngle()<e){
            driveTrain->TankDrive(0.6,-0.6);
            time_t taken = time(NULL) - start;
            if (taken > 5){//Sanity Check
                break;
            }
        }
    }
    else{
        while(getCurrentAngle()>e){
            driveTrain->TankDrive(-0.6,0.6);
            time_t taken = time(NULL) - start;
            if(taken>5){
                break;
            }
        }
    }
}

double DriveBase::getCurrentAngle(){
    //double heading = piggy->GetFusedHeading;
 double ypr[3];
piggy->GetYawPitchRoll(ypr); //gets yaw,pitch/roll
 double heading = ypr[0];
   return heading;

    //return 0.0;
}